/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable security/detect-object-injection */
/* eslint-disable max-lines */
import { useState, useRef, useEffect } from 'react';
import {
  DataGridPro,
  DataGridProProps,
  GridPaginationModel,
  GridRowScrollEndParams,
} from '@mui/x-data-grid-pro';
import { DataGrid, GridColDef } from '@mui/x-data-grid';
import LinearProgress from '@mui/material/LinearProgress';
import * as DM from '../sample-ecommerce-autogenerated';
import { ExecuteQueryParams, useExecuteQuery } from '../../query-execution';
import { QueryResultData } from '@sisense/sdk-data';
import { filters as filterFactory, measures as measureFactory } from '@sisense/sdk-data';

const MAX_ROW_LENGTH = 100000;
const PAGE_SIZE = 100;

interface GridRow {
  [key: string]: number | string;
}

type GridData = {
  columns: GridColDef[];
  rows: GridRow[];
};

/**
 * Transform data from QueryResultData to the data structure as required by Mui DataGrid
 *
 * @param data QueryResultData
 * @returns GridData
 */
function transformData(data: QueryResultData | undefined): GridData {
  if (!data) {
    return {
      columns: [],
      rows: [],
    };
  }

  const gridRows: GridRow[] = [];

  const { columns, rows } = data;

  rows.forEach((row, rowIndex) => {
    const item: GridRow = {};
    item.id = rowIndex;
    columns.forEach((column, colIndex) => {
      item[column.name] = row[colIndex].data;
    });
    gridRows.push(item);
  });

  const colList: GridColDef[] = columns.map((column) => ({
    field: column.name,
    headerName: column.name,
    flex: 1,
  }));

  return { columns: colList, rows: gridRows };
}

/**
 * Hook to execute a query and transform the data to the data structure as required by Mui DataGrid
 *
 * @param params - Input parameters for the query
 */
const useExecuteQueryMui = (params: ExecuteQueryParams) => {
  const { data, ...restQueryState } = useExecuteQuery(params);
  const transformedData = transformData(data);

  return {
    data: transformedData,
    ...restQueryState,
  };
};

export function MuiDataGridWithInfiniteLoading() {
  const [offset, setOffset] = useState(0);
  const [enabled, setEnabled] = useState(true);

  // const loadedRows = useRef<GridRow[]>([]);
  const [loadedRows, setLoadedRows] = useState<GridRow[]>([]);

  const dimensions = [DM.Category.Category, DM.Brand.Brand, DM.Commerce.Cost, DM.Commerce.Revenue];
  const filters = [filterFactory.greaterThan(DM.Commerce.Revenue, 10000)];
  const { isLoading, data } = useExecuteQueryMui({
    dimensions,
    filters,
    count: PAGE_SIZE,
    offset,
    enabled,
  });

  useEffect(() => {
    let ignore = false;

    if (data.rows.length && enabled) {
      // TODO: I ran into an issue with useExecuteQuery rendering multiple times causing the overlapping rows.
      // Will revisit this after https://sisenseglobal.atlassian.net/browse/SNS-99140 is addressed.
      // let rows: GridRow[] = [];
      // if (offset) {
      //   rows = loadedRows.slice(0, offset);
      // }
      // rows = rows.concat(data.rows);
      //
      // console.log('data.rows', data.rows);

      if (!ignore) {
        setLoadedRows(loadedRows.concat(data.rows));
        setEnabled(false);
      } else {
        setEnabled(true);
      }
    }

    return () => {
      // clean up function
      ignore = true;
    };
  }, [data, loadedRows, offset, enabled]);

  const handleOnRowsScrollEnd: DataGridProProps['onRowsScrollEnd'] = (
    params: GridRowScrollEndParams,
  ) => {
    // if there is no data to load, do nothing
    if (!params.viewportPageSize) return;

    if (loadedRows.length <= MAX_ROW_LENGTH && data.rows.length === PAGE_SIZE) {
      setOffset(offset + PAGE_SIZE);
      setEnabled(true);
    }
  };

  return (
    <div style={{ height: 400, width: 800, marginBottom: 20 }}>
      <DataGridPro
        columns={data.columns}
        rows={loadedRows}
        loading={isLoading}
        hideFooterPagination
        onRowsScrollEnd={handleOnRowsScrollEnd}
        slots={{
          loadingOverlay: LinearProgress,
        }}
      />
    </div>
  );
}

export function MuiDataGridWithServerPagination() {
  const [offset, setOffset] = useState(0);
  const rowCount = useRef(0);

  const paginationModel: GridPaginationModel = {
    page: offset / PAGE_SIZE,
    pageSize: PAGE_SIZE,
  };

  const dimensions = [DM.Category.Category, DM.Brand.Brand, DM.Commerce.Cost, DM.Commerce.Revenue];
  const filters = [filterFactory.greaterThan(DM.Commerce.Revenue, 10000)];
  // App developers should make a separate `useExecuteQuery` to get the total row count for pagination.
  // The count should apply to the fact attribute (raw data at atomic level), instead of dimension attribute.
  const { data: rowCountData } = useExecuteQuery({
    measures: [measureFactory.count(DM.Commerce.Cost, 'rowCount')],
    filters,
  });

  rowCount.current = rowCountData?.rows[0][0].data;

  const { isLoading, data } = useExecuteQueryMui({
    dimensions,
    filters,
    count: PAGE_SIZE,
    offset,
  });

  const handleOnPaginationModelChange = (model: GridPaginationModel) => {
    setOffset(model.page * PAGE_SIZE);
  };

  return (
    <div style={{ height: 400, width: 800, marginBottom: 20 }}>
      <DataGrid
        columns={data.columns}
        rows={data.rows}
        rowCount={rowCount.current}
        loading={isLoading}
        pageSizeOptions={[PAGE_SIZE]}
        paginationModel={paginationModel}
        paginationMode="server"
        onPaginationModelChange={handleOnPaginationModelChange}
      />
    </div>
  );
}

export function MuiDataGridDemo() {
  return (
    <div className="csdk-h-fit">
      With Server Pagination
      <MuiDataGridWithServerPagination />
      With Infinite Loading
      <MuiDataGridWithInfiniteLoading />
    </div>
  );
}
