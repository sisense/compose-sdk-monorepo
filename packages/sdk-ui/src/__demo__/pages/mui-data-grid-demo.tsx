/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable security/detect-object-injection */
/* eslint-disable max-lines */
import React, { useState, useRef, useEffect } from 'react';
import {
  DataGridPro,
  DataGridProProps,
  GridPaginationModel,
  GridRowScrollEndParams,
  GridRowSelectionModel,
  GridToolbarContainer,
} from '@mui/x-data-grid-pro';
import { DataGrid, GridColDef } from '@mui/x-data-grid';
import * as DM from '../sample-ecommerce-autogenerated';
import { ExecuteQuery, ExecuteQueryParams, useExecuteQuery } from '../../query-execution';
import { Attribute, QueryResultData } from '@sisense/sdk-data';
import { filterFactory, measureFactory } from '@sisense/sdk-data';
import { Button, IconButton, LinearProgress, Stack } from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';
import FilterListIcon from '@mui/icons-material/FilterList';
import { MenuPosition } from '../../types';
import { Box } from '@mui/system';
import { DrilldownWidget } from '../../widgets/drilldown-widget';
import { DataPointsEventHandler } from '../../chart-options-processor/apply-event-handlers';

const MAX_ROW_LENGTH = 100000;
const PAGE_SIZE = 50;

interface GridRow {
  [key: string]: number | string;
}

type GridData = {
  columns: GridColDef[];
  rows: GridRow[];
};

/**
 * Transform data from QueryResultData to the data structure as required by Mui DataGrid
 *
 * @param data QueryResultData
 * @param offsetIndex offset index
 * @returns GridData
 */
function transformData(data: QueryResultData | undefined, offsetIndex = 0): GridData {
  if (!data) {
    return {
      columns: [],
      rows: [],
    };
  }

  const gridRows: GridRow[] = [];

  const { columns, rows } = data;

  rows.forEach((row, rowIndex) => {
    const item: GridRow = {};
    // use offsetIndex to generate unique id for each row across pages
    // this is required by infinite loading
    item.id = offsetIndex + rowIndex;
    columns.forEach((column, colIndex) => {
      item[column.name] = row[colIndex].data;
    });
    gridRows.push(item);
  });

  const colList: GridColDef[] = columns.map((column) => ({
    field: column.name,
    headerName: column.name,
    flex: 1,
  }));

  return { columns: colList, rows: gridRows };
}

/**
 * Hook to execute a query and transform the data to the data structure as required by Mui DataGrid
 *
 * @param params - Input parameters for the query
 */
const useExecuteQueryMui = (params: ExecuteQueryParams) => {
  const { offset: offsetIndex } = params;
  const { data, ...restQueryState } = useExecuteQuery(params);
  const transformedData = transformData(data, offsetIndex);

  return {
    data: transformedData,
    ...restQueryState,
  };
};

export function MuiDataGridWithServerPagination() {
  const [offset, setOffset] = useState(0);
  const rowCount = useRef(0);

  const paginationModel: GridPaginationModel = {
    page: offset / PAGE_SIZE,
    pageSize: PAGE_SIZE,
  };

  const dimensions = [DM.Category.Category, DM.Brand.Brand, DM.Commerce.Cost, DM.Commerce.Revenue];
  const filters = [filterFactory.greaterThan(DM.Commerce.Revenue, 10000)];
  // App developers should make a separate `useExecuteQuery` to get the total row count for pagination.
  // The count should apply to the fact attribute (raw data at atomic level), instead of dimension attribute.
  const { isLoading: isLoadingRowCount, data: rowCountData } = useExecuteQuery({
    measures: [measureFactory.count(DM.Commerce.Revenue, 'rowCount')],
    filters,
  });

  rowCount.current = rowCountData?.rows[0][0].data;

  const { isLoading, data } = useExecuteQueryMui({
    dimensions,
    filters,
    count: PAGE_SIZE,
    offset,
  });

  const handleOnPaginationModelChange = (model: GridPaginationModel) => {
    setOffset(model.page * PAGE_SIZE);
  };

  if (isLoadingRowCount) {
    return <div>Loading...</div>;
  }

  const handleRefresh = () => {
    setOffset(0);
  };

  return (
    <div style={{ height: 400, width: 1000 }}>
      <Stack direction="row" spacing={1}>
        <h3 style={{ marginTop: '8px' }}>With Server Pagination</h3>
        <IconButton onClick={handleRefresh} aria-label="Refresh">
          <RefreshIcon />
        </IconButton>
      </Stack>
      <DataGrid
        columns={data.columns}
        rows={data.rows}
        rowCount={rowCount.current}
        loading={isLoading}
        pageSizeOptions={[PAGE_SIZE]}
        paginationModel={paginationModel}
        paginationMode="server"
        onPaginationModelChange={handleOnPaginationModelChange}
      />
    </div>
  );
}

export function MuiDataGridWithInfiniteLoading() {
  const [offset, setOffset] = useState(0);
  const [enabled, setEnabled] = useState(true);
  const [refreshed, setRefreshed] = useState(false);

  const [loadedRows, setLoadedRows] = useState<GridRow[]>([]);
  const dimensions = [DM.Category.Category, DM.Brand.Brand, DM.Commerce.Cost, DM.Commerce.Revenue];
  const filters = [filterFactory.greaterThan(DM.Commerce.Revenue, 10000)];
  const { isLoading, data } = useExecuteQueryMui({
    dimensions,
    filters,
    count: PAGE_SIZE,
    offset,
    enabled,
  });

  useEffect(() => {
    let ignore = false;

    if (!isLoading && !ignore && enabled && data && loadedRows.length <= offset) {
      setLoadedRows((prevRows) => {
        return [...prevRows, ...data.rows];
      });
    }

    return () => {
      // clean up function
      ignore = true;
    };
  }, [data, loadedRows, offset, enabled, isLoading]);

  const handleOnRowsScrollEnd: DataGridProProps['onRowsScrollEnd'] = (
    params: GridRowScrollEndParams,
  ) => {
    const { viewportPageSize, visibleRowsCount } = params;

    // if there is no data to load, do nothing
    if (!viewportPageSize) return;

    // if the data grid is just refreshed, do nothing
    if (refreshed) {
      setRefreshed(false);
      return;
    }

    // if the visible rows count is greater than the max row length, do nothing
    if (visibleRowsCount > MAX_ROW_LENGTH) {
      setEnabled(false);
      return;
    }

    if (data.rows.length < PAGE_SIZE) {
      setEnabled(false);
      return;
    }

    setEnabled(true);
    setOffset(offset + PAGE_SIZE);
  };

  const handleRefresh = () => {
    setLoadedRows([]);
    setEnabled(true);
    setOffset(0);
    setRefreshed(true);
  };

  return (
    <div style={{ height: 400, width: 1000 }}>
      <Stack direction="row" spacing={1}>
        <h3 style={{ marginTop: '8px' }}>With Infinite Loading</h3>
        <IconButton onClick={handleRefresh} aria-label="Refresh">
          <RefreshIcon />
        </IconButton>
      </Stack>

      <DataGridPro
        columns={data.columns}
        rows={loadedRows}
        loading={isLoading}
        hideFooterPagination
        onRowsScrollEnd={handleOnRowsScrollEnd}
        slots={{
          loadingOverlay: LinearProgress,
        }}
      />
    </div>
  );
}

type MuiDataGridDrilldownHelperProps = {
  filterCategory: Attribute;
  queryData: QueryResultData;
  breadcrumbsComponent: React.ReactNode;
  onDataPointsSelected: DataPointsEventHandler;
  onContextMenu: (menuPosition: MenuPosition) => void;
};

const MuiDataGridDrilldownHelper: React.FC<MuiDataGridDrilldownHelperProps> = ({
  filterCategory,
  queryData,
  breadcrumbsComponent,
  onDataPointsSelected,
  onContextMenu,
}) => {
  const { columns, rows } = transformData(queryData);

  const [rowSelectionModel, setRowSelectionModel] = useState<GridRowSelectionModel>([]);

  useEffect(() => {
    // clear selection when filter category changes
    setRowSelectionModel([]);
  }, [filterCategory]);

  const handleRowSelectionModelChange = (model: GridRowSelectionModel) => {
    setRowSelectionModel(model);

    // convert MUI row selection model to data points for drill down
    const selectedDataPoints = model.map((rowIndex) => {
      const row = rows[rowIndex];
      return {
        value: undefined,
        categoryValue: row[filterCategory.name] as string,
        categoryDisplayValue: row[filterCategory.name] as string,
        seriesValue: undefined,
      };
    });

    onDataPointsSelected(selectedDataPoints, new MouseEvent('mousemove'));
  };

  const handleDrilldown = (event: React.MouseEvent) => {
    onContextMenu({ left: event.clientX, top: event.clientY });
  };

  function CustomToolbar() {
    return (
      <GridToolbarContainer>
        <Button
          variant="outlined"
          size="small"
          startIcon={<FilterListIcon />}
          onClick={handleDrilldown}
          disabled={!rowSelectionModel.length}
        >
          Drill down
        </Button>
        <div style={{ width: '80%' }}>{breadcrumbsComponent}</div>
      </GridToolbarContainer>
    );
  }

  return (
    <Box sx={{ width: 1000, height: 700, mt: 1 }}>
      <DataGrid
        slots={{
          toolbar: CustomToolbar,
        }}
        rows={rows}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: { pageSize: PAGE_SIZE },
          },
        }}
        onRowSelectionModelChange={handleRowSelectionModelChange}
        rowSelectionModel={rowSelectionModel}
        pageSizeOptions={[PAGE_SIZE]}
        checkboxSelection={true}
      />
    </Box>
  );
};

export function MuiDataGridWithDrilldownOnCategory() {
  return (
    <DrilldownWidget
      drilldownDimensions={[DM.Commerce.AgeRange, DM.Commerce.Gender, DM.Commerce.Condition]}
      initialDimension={DM.Category.Category}
      config={{ isBreadcrumbsDetached: true }}
    >
      {({
        drilldownFilters,
        drilldownDimension,
        breadcrumbsComponent,
        onDataPointsSelected,
        onContextMenu,
      }) => (
        <ExecuteQuery
          dataSource={DM.DataSource}
          dimensions={[drilldownDimension]}
          measures={[
            measureFactory.sum(DM.Commerce.Quantity, 'Total Quantity'),
            measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue'),
            measureFactory.sum(DM.Commerce.Cost, 'Total Cost'),
          ]}
          filters={drilldownFilters}
        >
          {({ data }) => {
            if (data) {
              return (
                <>
                  <h3 style={{ marginTop: '8px' }}>With Drilldown On Category Initially</h3>
                  <MuiDataGridDrilldownHelper
                    filterCategory={drilldownDimension}
                    queryData={data}
                    breadcrumbsComponent={breadcrumbsComponent}
                    onContextMenu={onContextMenu}
                    onDataPointsSelected={onDataPointsSelected}
                  />
                </>
              );
            }
            return null;
          }}
        </ExecuteQuery>
      )}
    </DrilldownWidget>
  );
}

export function MuiDataGridWithDrilldownOnDates() {
  return (
    <DrilldownWidget
      drilldownDimensions={[
        DM.Commerce.Date.Quarters,
        DM.Commerce.Date.Months,
        DM.Category.Category,
        DM.Commerce.AgeRange,
        DM.Commerce.Condition,
      ]}
      initialDimension={DM.Commerce.Date.Years}
      config={{ isBreadcrumbsDetached: true }}
    >
      {({
        drilldownFilters,
        drilldownDimension,
        breadcrumbsComponent,
        onDataPointsSelected,
        onContextMenu,
      }) => (
        <ExecuteQuery
          dataSource={DM.DataSource}
          dimensions={[drilldownDimension, DM.Commerce.Gender]}
          measures={[
            measureFactory.sum(DM.Commerce.Quantity, 'Total Quantity'),
            measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue'),
            measureFactory.sum(DM.Commerce.Cost, 'Total Cost'),
          ]}
          filters={drilldownFilters}
        >
          {({ data }) => {
            if (data) {
              return (
                <>
                  <h3 style={{ marginTop: '8px' }}>With Drilldown On Dates Initially</h3>
                  <MuiDataGridDrilldownHelper
                    filterCategory={drilldownDimension}
                    queryData={data}
                    breadcrumbsComponent={breadcrumbsComponent}
                    onContextMenu={onContextMenu}
                    onDataPointsSelected={onDataPointsSelected}
                  />
                </>
              );
            }
            return null;
          }}
        </ExecuteQuery>
      )}
    </DrilldownWidget>
  );
}

export function MuiDataGridDemo() {
  return (
    <div className="csdk-h-fit">
      <MuiDataGridWithDrilldownOnCategory />
      <div style={{ height: '100px' }} />
      <MuiDataGridWithDrilldownOnDates />
      <div style={{ height: '100px' }} />
      <MuiDataGridWithServerPagination />
      <div style={{ height: '100px' }} />
      <MuiDataGridWithInfiniteLoading />
      <div style={{ height: '100px' }} />
    </div>
  );
}
