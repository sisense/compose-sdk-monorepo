import { convertDataSource, JaqlDataSourceForDto } from '@ethings-os/sdk-data';
import { NormalizedTable, NlqResponseJSON, NlqTranslationResult } from '../types.js';
import { BaseQueryParams } from '@/query-execution';
import { translateFiltersJSON, translateHighlightsJSON } from './translate-filters.js';
import { translateDimensionsJSON } from './translate-dimensions.js';
import { translateMeasuresJSON } from './translate-measures.js';

/**
 * Collects errors from multiple translation operations and returns either all successful results or all errors.
 *
 * @param translations - Object mapping context names to translation functions that return NlqTranslationResult<T>
 * @returns Either successful results for all translations or collected errors from failed ones
 */
function collectTranslationResults(
  translations: Record<string, () => NlqTranslationResult<unknown>>,
): NlqTranslationResult<Record<string, unknown>> {
  const results: Record<string, unknown> = {};
  const allErrors: string[] = [];

  for (const context in translations) {
    const translationFn = translations[`${context}`];
    const result = translationFn();
    if (result.success) {
      results[`${context}`] = result.data;
    } else {
      // Prefix each error with context and add to collection
      const contextualErrors = result.errors.map((error) => `[${context}] ${error}`);
      allErrors.push(...contextualErrors);
    }
  }

  if (allErrors.length > 0) {
    return { success: false, errors: allErrors };
  }

  return { success: true, data: results };
}
/**
 * Translate Query JSON generated by the new NLQ API to BaseQueryParams object.
 *
 * @example
 * {
      dimensions: ['DM.Category.Category', 'DM.Brand.Brand'],
      measures: [
        {
          function: 'measureFactory.sum',
          args: ['DM.Commerce.Revenue', 'Total Revenue'],
        },
        {
          function: 'measureFactory.sum',
          args: ['DM.Commerce.Cost', 'Total Cost'],
        },
      ],
      filters: [
        {
          function: 'filterFactory.members',
          args: ['DM.Commerce.Date.Years', ['2024-01-01T00:00:00']],
        },
        {
          function: 'filterFactory.topRanking',
          args: [
            'DM.Brand.Brand',
            {
              function: 'measureFactory.sum',
              args: ['DM.Commerce.Revenue', 'Total Revenue'],
            },
            5,
          ],
        },
      ],
    }
 *
 * is translated to the following Query object:
 * {
  "dataSource": {
    "address": "LocalHost",
    "id": "localhost_aSampleIAAaECommerce",
    "title": "Sample ECommerce",
    "type": "elasticube",
  },
  "dimensions": [
    {
      "__serializable": "DimensionalAttribute",
      "composeCode": "DM.Category.Category",
      "dataSource": {
        "address": "LocalHost",
        "id": "localhost_aSampleIAAaECommerce",
        "live": false,
        "title": "Sample ECommerce",
      },
      "description": "",
      "expression": "[Category.Category]",
      "name": "Category",
      "type": "text-attribute",
    },
    {
      "__serializable": "DimensionalAttribute",
      "composeCode": "DM.Brand.Brand",
      "dataSource": {
        "address": "LocalHost",
        "id": "localhost_aSampleIAAaECommerce",
        "live": false,
        "title": "Sample ECommerce",
      },
      "description": "",
      "expression": "[Brand.Brand]",
      "name": "Brand",
      "type": "text-attribute",
    },
  ],
  "filters": [
    {
      "__serializable": "RankingFilter",
      "_name": "filter",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Brand.Brand",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Brand.Brand]",
        "name": "Brand",
        "type": "text-attribute",
      },
      "composeCode": "filterFactory.topRanking(DM.Brand.Brand, measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue'), 5)",
      "config": {
        "disabled": false,
        "locked": false,
      },
      "count": 5,
      "description": "",
      "filterType": "ranking",
      "isScope": true,
      "measure": {
        "__serializable": "DimensionalBaseMeasure",
        "aggregation": "sum",
        "attribute": {
          "__serializable": "DimensionalAttribute",
          "composeCode": "DM.Commerce.Revenue",
          "dataSource": {
            "address": "LocalHost",
            "id": "localhost_aSampleIAAaECommerce",
            "live": false,
            "title": "Sample ECommerce",
          },
          "description": "",
          "expression": "[Commerce.Revenue]",
          "name": "Revenue",
          "type": "numeric-attribute",
        },
        "composeCode": "measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue')",
        "dataSource": undefined,
        "description": "",
        "name": "Total Revenue",
        "sort": 0,
        "type": "basemeasure",
      },
      "operator": "top",
      "type": "filter",
    },
    {
      "__serializable": "MembersFilter",
      "_name": "filter",
      "attribute": {
        "__serializable": "DimensionalLevelAttribute",
        "composeCode": "DM.Commerce.Date.Years",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Date]",
        "format": "yyyy",
        "granularity": "Years",
        "name": "Date",
        "type": "datelevel",
      },
      "composeCode": "filterFactory.members(DM.Commerce.Date.Years, ['2024-01-01T00:00:00'], { disabled: false, locked: false, excludeMembers: false, enableMultiSelection: true, deactivatedMembers: [] })",
      "config": {
        "deactivatedMembers": [],
        "disabled": false,
        "enableMultiSelection": true,
        "excludeMembers": false,
        "locked": false,
      },
      "description": "",
      "filterType": "members",
      "isScope": true,
      "members": [
        "2024-01-01T00:00:00",
      ],
      "type": "filter",
    },
  ],
  "measures": [
    {
      "__serializable": "DimensionalBaseMeasure",
      "aggregation": "sum",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Commerce.Revenue",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Revenue]",
        "name": "Revenue",
        "type": "numeric-attribute",
      },
      "composeCode": "measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue')",
      "dataSource": undefined,
      "description": "",
      "name": "Total Revenue",
      "sort": 0,
      "type": "basemeasure",
    },
    {
      "__serializable": "DimensionalBaseMeasure",
      "aggregation": "sum",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Commerce.Cost",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Cost]",
        "name": "Cost",
        "type": "numeric-attribute",
      },
      "composeCode": "measureFactory.sum(DM.Commerce.Cost, 'Total Cost')",
      "dataSource": undefined,
      "description": "",
      "name": "Total Cost",
      "sort": 0,
      "type": "basemeasure",
    },
  ],
}
 * @param queryJSON - A JSON string representing the query generated by the new NLQ API
 * @param dataSource - The data source to use for the query
 * @param tables - The tables to use for the query
 * @returns BaseQueryParams object
 * @internal
 */
export const translateQueryJSON = (
  queryJSON: NlqResponseJSON,
  dataSource: JaqlDataSourceForDto,
  tables: NormalizedTable[],
): BaseQueryParams => {
  // Collect all translation operations
  const translations: Record<string, () => NlqTranslationResult<unknown>> = {
    dimensions: () => translateDimensionsJSON(queryJSON.dimensions || [], dataSource, tables),
    measures: () => translateMeasuresJSON(queryJSON.measures || [], dataSource, tables),
    filters: () => translateFiltersJSON(queryJSON.filters || [], dataSource, tables),
  };

  // Add highlights translation if highlights exist
  if (queryJSON.highlights) {
    translations.highlights = () =>
      translateHighlightsJSON(queryJSON.highlights || [], dataSource, tables);
  }

  // Execute all translations and collect errors
  const translationResult = collectTranslationResults(translations);

  if (!translationResult.success) {
    const errorCount = translationResult.errors.length;
    const errorMessage = `Translation failed with ${errorCount} error(s):\n${translationResult.errors.join(
      '\n',
    )}`;
    throw new Error(errorMessage);
  }

  return {
    dataSource: convertDataSource(dataSource),
    ...translationResult.data,
  };
};
