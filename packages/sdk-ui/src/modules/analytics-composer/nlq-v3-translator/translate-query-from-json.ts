import { Attribute, convertDataSource, Filter, FilterRelations, Measure } from '@sisense/sdk-data';

import { BaseQueryParams } from '@/domains/query-execution/index.js';

import { NlqTranslationError, NlqTranslationResult } from '../types.js';
import { QueryInput } from '../types.js';
import { collectTranslationErrors, createSchemaIndex } from './common.js';
import { translateDimensionsFromJSON } from './translate-dimensions-from-json.js';
import {
  translateFiltersFromJSON,
  translateHighlightsFromJSON,
} from './translate-filters-from-json.js';
import { translateMeasuresFromJSON } from './translate-measures-from-json.js';

/**
 * Translates NLQ JSON format to CSDK BaseQueryParams object.
 * Direction: JSON â†’ CSDK
 *
 * Translate Query JSON generated by the new NLQ API to BaseQueryParams object.
 *
 * @example
 * {
     dimensions: ['DM.Category.Category', 'DM.Brand.Brand'],
     measures: [
       {
         function: 'measureFactory.sum',
         args: ['DM.Commerce.Revenue', 'Total Revenue'],
       },
       {
         function: 'measureFactory.sum',
         args: ['DM.Commerce.Cost', 'Total Cost'],
       },
     ],
     filters: [
       {
         function: 'filterFactory.members',
         args: ['DM.Commerce.Date.Years', ['2024-01-01T00:00:00']],
       },
       {
         function: 'filterFactory.topRanking',
         args: [
           'DM.Brand.Brand',
           {
             function: 'measureFactory.sum',
             args: ['DM.Commerce.Revenue', 'Total Revenue'],
           },
           5,
         ],
       },
     ],
   }
 *
 * is translated to the following Query object:
 * {success: true, data: {
  "dataSource": {
    "address": "LocalHost",
    "id": "localhost_aSampleIAAaECommerce",
    "title": "Sample ECommerce",
    "type": "elasticube",
  },
  "dimensions": [
    {
      "__serializable": "DimensionalAttribute",
      "composeCode": "DM.Category.Category",
      "dataSource": {
        "address": "LocalHost",
        "id": "localhost_aSampleIAAaECommerce",
        "live": false,
        "title": "Sample ECommerce",
      },
      "description": "",
      "expression": "[Category.Category]",
      "name": "Category",
      "type": "text-attribute",
    },
    {
      "__serializable": "DimensionalAttribute",
      "composeCode": "DM.Brand.Brand",
      "dataSource": {
        "address": "LocalHost",
        "id": "localhost_aSampleIAAaECommerce",
        "live": false,
        "title": "Sample ECommerce",
      },
      "description": "",
      "expression": "[Brand.Brand]",
      "name": "Brand",
      "type": "text-attribute",
    },
  ],
  "filters": [
    {
      "__serializable": "RankingFilter",
      "_name": "filter",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Brand.Brand",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Brand.Brand]",
        "name": "Brand",
        "type": "text-attribute",
      },
      "composeCode": "filterFactory.topRanking(DM.Brand.Brand, measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue'), 5)",
      "config": {
        "disabled": false,
        "locked": false,
      },
      "count": 5,
      "description": "",
      "filterType": "ranking",
      "isScope": true,
      "measure": {
        "__serializable": "DimensionalBaseMeasure",
        "aggregation": "sum",
        "attribute": {
          "__serializable": "DimensionalAttribute",
          "composeCode": "DM.Commerce.Revenue",
          "dataSource": {
            "address": "LocalHost",
            "id": "localhost_aSampleIAAaECommerce",
            "live": false,
            "title": "Sample ECommerce",
          },
          "description": "",
          "expression": "[Commerce.Revenue]",
          "name": "Revenue",
          "type": "numeric-attribute",
        },
        "composeCode": "measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue')",
        "dataSource": undefined,
        "description": "",
        "name": "Total Revenue",
        "sort": 0,
        "type": "basemeasure",
      },
      "operator": "top",
      "type": "filter",
    },
    {
      "__serializable": "MembersFilter",
      "_name": "filter",
      "attribute": {
        "__serializable": "DimensionalLevelAttribute",
        "composeCode": "DM.Commerce.Date.Years",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Date]",
        "format": "yyyy",
        "granularity": "Years",
        "name": "Date",
        "type": "datelevel",
      },
      "composeCode": "filterFactory.members(DM.Commerce.Date.Years, ['2024-01-01T00:00:00'], { disabled: false, locked: false, excludeMembers: false, enableMultiSelection: true, deactivatedMembers: [] })",
      "config": {
        "deactivatedMembers": [],
        "disabled": false,
        "enableMultiSelection": true,
        "excludeMembers": false,
        "locked": false,
      },
      "description": "",
      "filterType": "members",
      "isScope": true,
      "members": [
        "2024-01-01T00:00:00",
      ],
      "type": "filter",
    },
  ],
  "measures": [
    {
      "__serializable": "DimensionalBaseMeasure",
      "aggregation": "sum",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Commerce.Revenue",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Revenue]",
        "name": "Revenue",
        "type": "numeric-attribute",
      },
      "composeCode": "measureFactory.sum(DM.Commerce.Revenue, 'Total Revenue')",
      "dataSource": undefined,
      "description": "",
      "name": "Total Revenue",
      "sort": 0,
      "type": "basemeasure",
    },
    {
      "__serializable": "DimensionalBaseMeasure",
      "aggregation": "sum",
      "attribute": {
        "__serializable": "DimensionalAttribute",
        "composeCode": "DM.Commerce.Cost",
        "dataSource": {
          "address": "LocalHost",
          "id": "localhost_aSampleIAAaECommerce",
          "live": false,
          "title": "Sample ECommerce",
        },
        "description": "",
        "expression": "[Commerce.Cost]",
        "name": "Cost",
        "type": "numeric-attribute",
      },
      "composeCode": "measureFactory.sum(DM.Commerce.Cost, 'Total Cost')",
      "dataSource": undefined,
      "description": "",
      "name": "Total Cost",
      "sort": 0,
      "type": "basemeasure",
    },
  ],
}}
 * @param input - QueryInput object
 * @returns NlqTranslationResult<BaseQueryParams>
 * @internal
 */
export const translateQueryFromJSON = (
  input: QueryInput,
): NlqTranslationResult<BaseQueryParams> => {
  const { data: queryJSON } = input;
  const { dataSource, tables } = input.context;

  // Create schema index once from tables for efficient lookups
  const schemaIndex = createSchemaIndex(tables);

  const translationErrors: NlqTranslationError[] = [];

  // Process each translation category
  const dimensions = collectTranslationErrors<Attribute[]>(
    () =>
      translateDimensionsFromJSON({
        data: queryJSON.dimensions || [],
        context: { dataSource, schemaIndex },
      }),
    translationErrors,
  );

  const measures = collectTranslationErrors<Measure[]>(
    () =>
      translateMeasuresFromJSON({
        data: queryJSON.measures || [],
        context: { dataSource, schemaIndex },
      }),
    translationErrors,
  );

  const filters = collectTranslationErrors<Filter[] | FilterRelations>(
    () =>
      translateFiltersFromJSON({
        data: queryJSON.filters || [],
        context: { dataSource, schemaIndex },
      }),
    translationErrors,
  );

  let highlights = null;
  if (queryJSON.highlights) {
    highlights = collectTranslationErrors<Filter[]>(
      () =>
        translateHighlightsFromJSON({
          data: queryJSON.highlights || [],
          context: { dataSource, schemaIndex },
        }),
      translationErrors,
    );
  }

  // If any errors were collected, return structured error response
  if (translationErrors.length > 0) {
    return {
      success: false,
      errors: translationErrors,
    };
  }

  // Return successful result
  const result = {
    dataSource: convertDataSource(dataSource),
    dimensions: dimensions || [],
    measures: measures || [],
    filters: filters || [],
    ...(highlights && { highlights: highlights }),
  };

  return {
    success: true,
    data: result,
  };
};
